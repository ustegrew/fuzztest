/* -----------------------------------------------------------------------------
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------------- */

package fuzztest.generator;

import fuzztest.generator.classing.TClass;

/**
 * Browseable object, i.e. can be stored in the {@link TRepository}. Provides 
 * manual and automatic key generation. 
 * 
 * @author peter
 */
public abstract class VBrowseable
{
    /**
     * Creates a generic {@link TClass} from this abstract class.
     * Use case: {@link TRepository} Query with abstract base class as 
     *           query criterion.
     *           
     * Thankfully, Java allows us to create anonymous instances of 
     * abstract classes, otherwise it would be hard to instantiate 
     * a {@link TClass} from an abstract class.
     * 
     * Note that each abstract sub class must override this method!  
     * 
     * @return      A generic class object for this class.
     */
    public static TClass CreateType ()
    {
        TClass      ret;
        
        ret = (new VBrowseableType ()).GetClass ();
        
        return ret;
    }
    private static class VBrowseableType extends VBrowseable {} /* [110] */
    
    private static int      gCounter = -1;
    
    private TClass          fClass;
    private String          fKey;
    
    /**
     * cTor. 
     */
    protected VBrowseable ()
    {
        fClass      = TClass.Create (this);
        fKey        = null;
    }
    
    public TClass GetClass ()
    {
        return fClass;
    }
    
    /**
     * @return      The key associated with this object. 
     */
    public String GetKey ()
    {
        return fKey;
    }
    
    /**
     * Assigns an autogenerated key, usually from the cTor of the concrete sub class.
     * Then registers this object with the repository.
     * 
     *  @throws IllegalArgumentException if a key has already been assigned before.
     */
    protected void _Register ()
    {
        _Register (null, true);
    }
    
    /**
     * Assigns the given key to this object. Key can only be assigned once. Used by rules
     * that have their ID property set in the given grammar.
     * Then registers this object with the repository.
     * 
     * @param   key       The key to be assigned.
     * @throws  IllegalArgumentException if a key has already been assigned.
     */
    protected void _Register (String key)
    {
        _Register (key, false);
    }
    
    private void _Register (String key, boolean doAutoKey)
    {
        String      k;
        
        if (fKey != null)
        {
            throw new IllegalArgumentException ("Key is already assigned.");
        }
        
        if (doAutoKey)
        {
            k = fClass.GetName ();
            gCounter++;
            fKey = k + "_" + gCounter;
        }
        else
        {
            fKey = key;
        }
        
        TRepository.Add (this);
    }
}

/*
[100]   Double cast, necessary to satisfy the Java compiler. Will be reduced
        to simple assignment in trans-piled code.
        
[110]   Unfortunately we have to create an explicit dummy class that inherits from 
        VBrowseable. Otherwise we could create a VBrowseable type using a shorter and more 
        elegant one-liner: 
            TClass c = (new VBrowseable(){}).GetClass().GetParent(); 
        the shorter version leads to a complaint by the Typescript to JS compiler:
            Cannot create an instance of the abstract class 'VBrowseable'. 
        This is, because the one-liner leads to this typescript code:
            ret = (((target:VBrowseable) => {
                return target;
            })(new VBrowseable())).GetClass();
        and Typescript correctly complains that we are trying to create an instance of 
        an abstract class. With the workaround we now get the correct Typescript
        code:
            ret = (new VBrowseable.VBrowseableType()).GetClass();
        which is accepted by Typescript.
*/

