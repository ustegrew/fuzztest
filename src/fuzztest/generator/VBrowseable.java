/* -----------------------------------------------------------------------------
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------------- */

package fuzztest.generator;

import fuzztest.model.abstracts.TClass;

/**
 * Browseable object, i.e. can be stored in the {@link TRepository}. Provides 
 * manual and automatic key generation. 
 * 
 * @author peter
 */
public abstract class VBrowseable
{
    /**
     * A dummy class to provide a concrete derivative from the hosting abstract class.
     * Purely needed so we have something to instantiate (TClass cTor needs an object). 
     */
    private static class VBrowseableT extends VBrowseable {} /* [110] */
    /**
     * The {@link TClass} of this class for type information. 
     */
    public static final TClass gClass = (new VBrowseableT ()).GetClass ().GetParent ();

    private static int      gCounter = -1;
    
    private TClass          fClass;
    private String          fKey;
    
    /**
     * cTor. 
     */
    protected VBrowseable ()
    {
        fClass      = TClass.Create (this);
        fKey        = null;
    }
    
    public TClass GetClass ()
    {
        return fClass;
    }
    
    /**
     * @return      The key associated with this object. 
     */
    public String GetKey ()
    {
        return fKey;
    }
    
    /**
     * Assigns an autogenerated key, usually from the cTor of the concrete sub class.
     * Then registers this object with the repository.
     * 
     *  @throws IllegalArgumentException if a key has already been assigned before.
     */
    protected void _Register ()
    {
        _Register (null, true);
    }
    
    /**
     * Assigns the given key to this object. Key can only be assigned once. Used by rules
     * that have their ID property set in the given grammar.
     * Then registers this object with the repository.
     * 
     * @param   key       The key to be assigned.
     * @throws  IllegalArgumentException if a key has already been assigned.
     */
    protected void _Register (String key)
    {
        _Register (key, false);
    }
    
    private void _Register (String key, boolean doAutoKey)
    {
        String      k;
        
        if (fKey != null)
        {
            throw new IllegalArgumentException ("Key is already assigned.");
        }
        
        if (doAutoKey)
        {
            k = fClass.GetCanonicalPath ();
            gCounter++;
            fKey = k + "_" + gCounter;
        }
        else
        {
            fKey = key;
        }
        
        TRepository.Add (this);
    }
}

/*
[100]   Double cast, necessary to satisfy the Java compiler. Will be reduced
        to simple assignment in trans-piled code.
        
[110]   Unfortunately we have to create an explicit dummy class that inherits from 
        VBrowseable. Otherwise we could create a VBrowseable type using a shorter and more 
        elegant one-liner: 
            TClass c = (new VBrowseable(){}).GetClass().GetParent(); 
        the shorter version leads to a complaint by the Typescript to JS compiler:
            Cannot create an instance of the abstract class 'VBrowseable'. 
        This is, because the one-liner leads to this typescript code:
            ret = (((target:VBrowseable) => {
                return target;
            })(new VBrowseable())).GetClass();
        and Typescript correctly complains that we are trying to create an instance of 
        an abstract class. With the workaround we now get the correct Typescript
        code:
            ret = (new VBrowseable.VBrowseableT()).GetClass();
        which is accepted by Typescript.
        
[120]   Need to wrap this method into an inner class, otherwise we'll have a naming 
        conflict, because all concrete subclasses have a method with the same name. 
*/

